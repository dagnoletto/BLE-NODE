

/****************************************************************/
/* Includes                                                     */
/****************************************************************/
#include "hci.h"
#include "hci_transport_layer.h"
#include "Types.h"


/****************************************************************/
/* Type Defines                                                 */
/****************************************************************/


/****************************************************************/
/* Static functions declaration                                 */
/****************************************************************/


/****************************************************************/
/* Defines                                                      */
/****************************************************************/


/****************************************************************/
/* Global variables definition                                  */
/****************************************************************/


/****************************************************************/
/* Local variables definition                                   */
/****************************************************************/


/****************************************************************/
/* HCI_Disconnect()                         					*/
/* Location: Page 1940 Core_v5.2 								*/
/* Purpose: The HCI_Disconnect command is used to terminate an 	*/
/* existing connection. The Connection_Handle command parameter */
/* indicates which connection is to be disconnected. The Reason */
/* command parameter indicates the reason for ending the 		*/
/* connection and is copied into the error code field of the	*/
/* LMP_DETACH PDU on a BR/EDR connection or the error code field*/
/* of the LL_TERMINATE_IND PDU, or the LL_CIS_TERMINATE_IND PDU */
/* on an LE connection. All SCO, eSCO, and CIS connections on a */
/* physical link should be disconnected before the ACL 			*/
/* connection on the same physical connection is disconnected. 	*/
/* If it does not, they will be implicitly disconnected as part */
/* of the ACL disconnection. If this command is used to 		*/
/* disconnect a CIS, the connection handle of the CIS and the	*/
/* associated data paths of the CIS shall remain valid. If this */
/* command is issued for a CIS before the Controller has		*/
/* generated the HCI_CIS_Established event for that CIS, the 	*/
/* Controller shall return the error code Command Disallowed 	*/
/* (0x0C). Note: The Host can recreate a disconnected CIS at a 	*/
/* later point in time using the same connection handle.		*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Disconnect( uint16_t Connection_Handle, CONTROLLER_ERROR_CODES Reason )
{
	uint8_t Status = FALSE;

	if( Connection_Handle <= MAX_CONNECTION_HANDLE )
	{

		switch( Reason )
		{
		/* Not sure if other reason codes are supported. In the command specification, it
		 * explicit mentioned those: */
		case AUTHENTICATION_FAILURE:
		case REMOTE_USER_TERMINATED_CONNECTION:
		case REM_DEV_TERM_CONN_LOW_RESOURCES:
		case REM_DEV_TERM_CONN_POWER_OFF:
		case UNSUPPORTED_REMOTE_OR_LMP_FEATURE:
		case PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED:
		case UNACCEPTABLE_CONNECTION_PARAMETERS:
			break;

		default:
			return (Status);
			break;
		}

		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 3;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_DISCONNECT;
		PcktPtr->CmdPacket.Parameter_Total_Length = 3;

		PcktPtr->CmdPacket.Parameter[0] = Connection_Handle & 0xFF;
		PcktPtr->CmdPacket.Parameter[1] = ( Connection_Handle >> 8 ) & 0xFF;
		PcktPtr->CmdPacket.Parameter[2] = Reason;

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );

	}

	return (Status);
}


/****************************************************************/
/* HCI_Disconnect_Status()        	        					*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Disconnect command and HCI_Disconnection_Complete not	*/
/* issued yet.													*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Disconnect_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Remote_Version_Information()                        */
/* Location: Page 1974 Core_v5.2 								*/
/* Purpose: This command will obtain the values for the version */
/* information for the remote device identified by the 			*/
/* Connection_Handle parameter. The Connection_Handle shall be 	*/
/* a Connection_Handle for an ACL-U or LE-U logical link.		*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_Remote_Version_Information( uint16_t Connection_Handle )
{
	uint8_t Status = FALSE;

	if( Connection_Handle <= MAX_CONNECTION_HANDLE )
	{
		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 2;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_READ_REMOTE_VERSION_INFORMATION;
		PcktPtr->CmdPacket.Parameter_Total_Length = 2;

		PcktPtr->CmdPacket.Parameter[0] = Connection_Handle & 0xFF;
		PcktPtr->CmdPacket.Parameter[1] = ( Connection_Handle >> 8 ) & 0xFF;

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );
	}

	return (Status);
}


/****************************************************************/
/* HCI_Read_Remote_Version_Information_Status()          	    */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Remote_Version_Information command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Remote_Version_Information_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Set_Event_Mask()                        					*/
/* Location: Page 2074 Core_v5.2 								*/
/* Purpose: The HCI_Set_Event_Mask command is used to control 	*/
/* which events are generated by the HCI for the Host. If the 	*/
/* bit in the Event_Mask is set to a one, then the event 		*/
/* associated with that bit will be enabled. For an LE 			*/
/* Controller, the “LE Meta event” bit in the event_Mask shall 	*/
/* enable or disable all LE events in the LE Meta event			*/
/* (see Section 7.7.65). The event mask allows the Host to 		*/
/* control how much it is interrupted.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Set_Event_Mask( EVENT_MASK Event_Mask )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + sizeof(EVENT_MASK);
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_SET_EVENT_MASK;
	PcktPtr->CmdPacket.Parameter_Total_Length = sizeof(EVENT_MASK);

	for( int8_t i = 0; i < sizeof(EVENT_MASK); i++ )
	{
		PcktPtr->CmdPacket.Parameter[i] = Event_Mask.Bytes[i];
	}

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_Set_Event_Mask_Status()          	    				*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Set_Event_Mask command.									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Set_Event_Mask_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Set_Event_Mask_Complete()          	    				*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Set_Event_Mask command.									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Set_Event_Mask_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Transmit_Power_Level()             					*/
/* Location: Page 2121 Core_v5.2 								*/
/* Purpose: This command reads the values for the TX_Power_Level*/
/* parameter for the specified Connection_Handle. The 			*/
/* Connection_Handle shall be a Connection_Handle for an ACL 	*/
/* connection.													*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_Transmit_Power_Level( uint16_t Connection_Handle, uint8_t Type )
{
	uint8_t Status = FALSE;

	if( ( Connection_Handle <= MAX_CONNECTION_HANDLE ) && ( Type <= 1 ) )
	{
		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 3;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_READ_TRANSMIT_POWER_LEVEL;
		PcktPtr->CmdPacket.Parameter_Total_Length = 3;

		PcktPtr->CmdPacket.Parameter[0] = Connection_Handle & 0xFF;
		PcktPtr->CmdPacket.Parameter[1] = ( Connection_Handle >> 8 ) & 0xFF;
		PcktPtr->CmdPacket.Parameter[2] = Type;

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );
	}

	return (Status);
}


/****************************************************************/
/* HCI_Read_Transmit_Power_Level_Status()          	    		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Transmit_Power_Level command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Transmit_Power_Level_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Transmit_Power_Level_Complete()        	    		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Transmit_Power_Level command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Transmit_Power_Level_Complete( CONTROLLER_ERROR_CODES Status, uint16_t Connection_Handle, int8_t TX_Power_Level )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Reset()                        							*/
/* Location: Page 2077 Core_v5.2 								*/
/* Purpose: The HCI_Reset command will reset the Controller and */
/* the Link Manager on the BR/EDR Controller, the PAL on an AMP */
/* Controller, or the Link Layer on an LE Controller. If the 	*/
/* Controller supports both BR/EDR and LE then the HCI_Reset	*/
/* command shall reset the Link Manager, Baseband and Link 		*/
/* Layer. The HCI_Reset command shall not affect the used HCI 	*/
/* transport layer since the HCI transport layers may have reset*/
/* mechanisms of their own. After the reset is completed, the 	*/
/* current operational state will be lost, the Controller will 	*/
/* enter standby mode and the Controller will automatically 	*/
/* revert to the default values for the parameters for which 	*/
/* default values are defined in the specification. Note: The 	*/
/* HCI_Reset command will not necessarily perform a hardware 	*/
/* reset. This is implementation defined. The Host shall not 	*/
/* send additional HCI commands before the HCI_Command_Complete */
/* event related to the HCI_Reset command has been received.	*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Reset( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_RESET;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_Reset_Status()          	    							*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Reset command.											*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Reset_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Reset_Complete()          	    						*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Reset command.											*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Reset_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Version_Information()                         */
/* Location: Page 2223 Core_v5.2 								*/
/* Purpose: The HCI_Read_Local_Version_Information command 		*/
/* reads the values for the version information for the local	*/
/* Controller.   		    									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_Local_Version_Information( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_READ_LOCAL_VERSION_INFORMATION;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_Read_Local_Version_Information_Status()          	    */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Local_Version_Information command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Version_Information_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Version_Information_Complete()                */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Local_Version_Information command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Version_Information_Complete( CONTROLLER_ERROR_CODES Status,
		HCI_VERSION HCI_Version, uint16_t HCI_Revision,
		uint8_t LMP_PAL_Version, uint16_t Manufacturer_Name,
		uint16_t LMP_PAL_Subversion)
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Supported_Commands()                          */
/* Location: Page 2225 Core_v5.2 								*/
/* Purpose: This command reads the list of HCI commands 		*/
/* supported for the local Controller. This command shall 		*/
/* return the Supported_Commands configuration parameter. It is */
/* implied that if a command is listed as supported, the 		*/
/* feature underlying that command is also supported.			*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_Local_Supported_Commands( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_READ_LOCAL_SUPPORTED_COMMANDS;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_Read_Local_Supported_Commands_Status()          		    */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Local_Supported_Commands command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Supported_Commands_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Supported_Commands_Complete()        		    */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Local_Supported_Commands command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Supported_Commands_Complete( CONTROLLER_ERROR_CODES Status, SUPPORTED_COMMANDS* Supported_Commands )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Supported_Features()                          */
/* Location: Page 2226 Core_v5.2 								*/
/* Purpose: This command requests a list of the supported 		*/
/* features for the local BR/EDR Controller. This command will 	*/
/* return a list of the LMP features. For details see [Vol 2] 	*/
/* Part C, Link Manager Protocol Specification.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_Local_Supported_Features( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_READ_LOCAL_SUPPORTED_FEATURES;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_Read_Local_Supported_Features_Status()                   */
/* Location: 					 								*/
/* Purpose: Event generated by 									*/
/* the HCI_Read_Local_Supported_Features command.				*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Supported_Features_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Supported_Features_Complete()                 */
/* Location: 					 								*/
/* Purpose: Event generated by 									*/
/* the HCI_Read_Local_Supported_Features command.				*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Supported_Features_Complete( CONTROLLER_ERROR_CODES Status, SUPPORTED_FEATURES* LMP_Features )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_BD_ADDR()                          					*/
/* Location: Page 2231 Core_v5.2 								*/
/* Purpose: On a BR/EDR Controller, this command reads the 		*/
/* Bluetooth Controller address (BD_ADDR). (See [Vol 2] Part B, */
/* Section 1.2 and [Vol 3] Part C, Section 3.2.1). On an LE 	*/
/* Controller, this command shall read the Public Device Address*/
/* as defined in [Vol 6] Part B, Section 1.3. If this Controller*/
/* does not have a Public Device Address, the value 			*/
/* 0x000000000000 shall be returned. On a BR/EDR/LE Controller, */
/* the public address shall be the same as the BD_ADDR.			*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_BD_ADDR( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_READ_BD_ADDR;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_Read_BD_ADDR_Status()                					*/
/* Location: 					 								*/
/* Purpose: Event generated by 									*/
/* the HCI_Read_BD_ADDR command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_BD_ADDR_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_BD_ADDR_Complete()                					*/
/* Location: 					 								*/
/* Purpose: Event generated by 									*/
/* the HCI_Read_BD_ADDR command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_BD_ADDR_Complete( CONTROLLER_ERROR_CODES Status, BD_ADDR_TYPE BD_ADDR )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_RSSI()                          					*/
/* Location: Page 2249 Core_v5.2 								*/
/* Purpose: This command reads the Received Signal Strength 	*/
/* Indication (RSSI) value from a Controller.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_RSSI( uint16_t Handle )
{
	uint8_t Status = FALSE;

	if( Handle <= MAX_CONNECTION_HANDLE )
	{
		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 2;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_READ_RSSI;
		PcktPtr->CmdPacket.Parameter_Total_Length = 2;

		PcktPtr->CmdPacket.Parameter[0] = Handle & 0xFF;
		PcktPtr->CmdPacket.Parameter[1] = ( Handle >> 8 ) & 0xFF;

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );
	}

	return (Status);
}


/****************************************************************/
/* HCI_Read_RSSI_Status()                						*/
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_Read_RSSI command.		*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_RSSI_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_RSSI_Complete()                						*/
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_Read_RSSI command.		*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_RSSI_Complete( CONTROLLER_ERROR_CODES Status, uint16_t Handle, int8_t RSSI )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Event_Mask()                   		            */
/* Location: Page 2473 Core_v5.2								*/
/* Purpose: The HCI_LE_Set_Event_Mask command is used to control*/
/* which LE events are generated by the HCI for the Host. If the*/
/* bit in the LE_Event_Mask is set to a one, then the event 	*/
/* associated with that bit will be enabled. The event mask 	*/
/* allows the Host to control which events will interrupt it. 	*/
/* The Controller shall ignore those bits which are reserved for*/
/* future use or represent events which it does not support. If */
/* the Host sets any of these bits to 1, the Controller shall 	*/
/* act as if they were set to 0. For LE events to be generated, */
/* the LE Meta event bit in the Event_Mask shall also be set. 	*/
/* If that bit is not set, then LE events shall not be			*/
/* generated, regardless of how the LE_Event_Mask is set.		*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Event_Mask( LE_EVENT_MASK LE_Event_Mask )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + sizeof(LE_EVENT_MASK);
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_EVENT_MASK;
	PcktPtr->CmdPacket.Parameter_Total_Length = sizeof(LE_EVENT_MASK);

	for( int8_t i = 0; i < sizeof(LE_EVENT_MASK); i++ )
	{
		PcktPtr->CmdPacket.Parameter[i] = LE_Event_Mask.Bytes[i];
	}

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Event_Mask_Status()                				*/
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_LE_Set_Event_Mask		*/
/* command.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Event_Mask_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Event_Mask_Complete()                				*/
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_LE_Set_Event_Mask		*/
/* command.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Event_Mask_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_Buffer_Size()                  		            */
/* Location: Page 2476 Core_v5.2								*/
/* Purpose: This command is used to read the maximum size of the*/
/* data portion of ACL data packets and isochronous data packets*/
/* sent from the Host to the Controller. The Host shall segment */
/* the data transmitted to the Controller according to these 	*/
/* values so that the HCI Data packets and isochronous data 	*/
/* packets will contain data up to this size. The 				*/
/* HCI_LE_Read_Buffer_Size command also returns the total number*/
/* of HCI LE ACL Data packets and isochronous data packets that */
/* can be stored in the data buffers of the Controller. The 	*/
/* HCI_LE_Read_Buffer_Size command shall be issued by the Host 	*/
/* before it sends any data to an LE Controller 				*/
/* (see Section 4.1.1). If the Controller supports HCI ISO Data */
/* packets, it shall return non-zero values for the 			*/
/* ISO_Data_Packet_Length and Total_Num_ISO_Data_Packets 		*/
/* parameters. If the Controller returns a length value of zero */
/* for ACL data packets, the Host shall use the 				*/
/* HCI_Read_Buffer_Size command to determine the size of the 	*/
/* data buffers (shared between BR/EDR and LE transports). Note:*/
/* Both the HCI_Read_Buffer_Size command and the 				*/
/* HCI_LE_Read_Buffer_Size command may return buffer length and */
/* number of packets parameter values that are nonzero. This 	*/
/* allows a Controller to offer different buffers and number of */
/* buffers for BR/EDR data packets and LE data packets. The 	*/
/* LE_ACL_Data_Packet_Length return parameter shall be used to	*/
/* determine the maximum size of the L2CAP PDU segments that are*/
/* contained in ACL data packets, and which are transferred from*/
/* the Host to the Controller to be broken up into packets by 	*/
/* the Link Layer. The Total_Num_LE_ACL_Data_Packets return 	*/
/* parameter contains the total number of HCI ACL Data packets 	*/
/* that can be stored in the data buffers of the Controller. 	*/
/* The Host determines how to divide the buffers between 		*/
/* different connection handles. The ISO_Data_Packet_Length 	*/
/* return parameter shall be used to determine the maximum size */
/* of the SDU segments that are contained in isochronous data 	*/
/* packets, and which are transferred from the Host to the 		*/
/* Controller. The Total_Num_ISO_Data_Packets return parameter 	*/
/* contains the total number of isochronous data packets that 	*/
/* can be stored in the data buffers of the Controller. The Host*/
/* determines how to divide the buffers between different 		*/
/* connection handle(s). Note: The LE_ACL_Data_Packet_Length and*/
/* ISO_Data_Packet_Length return parameters do not include the 	*/
/* length of the HCI Data packet header or the HCI ISO Data 	*/
/* packet header respectively.									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Read_Buffer_Size( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_LE_READ_BUFFER_SIZE;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Read_Buffer_Size_Status()                				*/
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_LE_Read_Buffer_Size		*/
/* command.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_Buffer_Size_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_Buffer_Size_Complete()              				*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_Buffer_Size command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_Buffer_Size_Complete( CONTROLLER_ERROR_CODES Status, uint16_t LE_ACL_Data_Packet_Length,
		uint8_t Total_Num_LE_ACL_Data_Packets )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_Local_Supported_Features()                       */
/* Location: Page 2479 Core_v5.2								*/
/* Purpose: This command requests the list of the supported LE 	*/
/* features for the Controller.									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Read_Local_Supported_Features( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_LE_READ_LOCAL_SUPPORTED_FEATURES;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Read_Local_Supported_Features_Status()       			*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_Local_Supported_Features command.				*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_Local_Supported_Features_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_Local_Supported_Features_Complete()       		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_Local_Supported_Features command.				*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_Local_Supported_Features_Complete( CONTROLLER_ERROR_CODES Status, LE_SUPPORTED_FEATURES* LE_Features )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Random_Address()                               	*/
/* Location: Page 2480 Core_v5.2								*/
/* Purpose: The HCI_LE_Set_Random_Address command is used by 	*/
/* the Host to set the LE Random Device Address in the 			*/
/* Controller (see [Vol 6] Part B, Section 1.3). If this 		*/
/* command is used to change the address, the new random address*/
/* shall take effect for advertising no later than the next 	*/
/* successful HCI_LE_Set_Advertising_Enable command, for 		*/
/* scanning no later than the next successful 					*/
/* HCI_LE_Set_Scan_Enable command or 							*/
/* HCI_LE_Set_Extended_Scan_Enable command, and for initiating	*/
/* no later than the next successful HCI_LE_Create_Connection 	*/
/* command or HCI_LE_Extended_Create_Connection command. Note: 	*/
/* If the extended advertising commands are in use, this command*/
/* only affects the address used for scanning and initiating. 	*/
/* The addresses used for advertising are set by the 			*/
/* HCI_LE_Set_Advertising_Set_Random_Address command (see 		*/
/* Section 7.8.52). If the Host issues this command when any of */
/* advertising (created using legacy advertising commands), 	*/
/* scanning, or initiating are enabled, the Controller shall	*/
/* return the error code Command Disallowed (0x0C).				*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Random_Address( BD_ADDR_TYPE Random_Address )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + sizeof(Random_Address);
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_RANDOM_ADDRESS;
	PcktPtr->CmdPacket.Parameter_Total_Length = sizeof(Random_Address);

	for( int8_t i = 0; i < sizeof(Random_Address); i++ )
	{
		PcktPtr->CmdPacket.Parameter[i] = Random_Address.Byte[i];
	}

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Random_Address_Status()       					*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Random_Address command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Random_Address_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Random_Address_Complete()       					*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Random_Address command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Random_Address_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Parameters()                          */
/* Location: Page 2482 Core_v5.2								*/
/* Purpose:	The HCI_LE_Set_Advertising_Parameters command is 	*/
/* used by the Host to set the advertising parameters. The 		*/
/* Advertising_Interval_Min shall be less than or equal to the	*/
/* Advertising_Interval_Max. The Advertising_Interval_Min and	*/
/* Advertising_Interval_Max should not be the same value to 	*/
/* enable the Controller to determine the best advertising 		*/
/* interval given other activities. For high duty cycle directed*/
/* advertising, i.e. when Advertising_Type is 0x01 				*/
/* (ADV_DIRECT_IND, high duty cycle), the 						*/
/* Advertising_Interval_Min and Advertising_Interval_Max 		*/
/* parameters are not used and shall be ignored. The 			*/
/* Advertising_Type is used to determine the packet type that is*/
/* used for advertising when advertising is enabled. 			*/
/* Own_Address_Type parameter indicates the type of address 	*/
/* being used in the advertising packets. If Own_Address_Type 	*/
/* equals 0x02 or 0x03, the Peer_Address parameter contains the */
/* peer’s Identity Address and the Peer_Address_Type parameter	*/
/* contains the Peer’s Identity Type (i.e. 0x00 or 0x01). These */
/* parameters are used to locate the corresponding local IRK in */
/* the resolving list; this IRK is used to generate the own 	*/
/* address used in the advertisement. If directed advertising is*/
/* performed, i.e. when Advertising_Type is set to 0x01			*/
/* (ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, 	*/
/* low duty cycle mode), then the Peer_Address_Type and 		*/
/* Peer_Address shall be valid. If Own_Address_Type equals 0x02 */
/* or 0x03, the Controller generates the peer’s Resolvable 		*/
/* Private Address using the peer’s IRK corresponding to the	*/
/* peer’s Identity Address contained in the Peer_Address		*/
/* parameter and peer’s Identity Address Type (i.e. 0x00 or 	*/
/* 0x01) contained in the Peer_Address_Type	parameter.			*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Advertising_Parameters( uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, ADVERTISING_TYPE Advertising_Type,
		ADDRESS_TYPE Own_Address_Type, ADDRESS_TYPE Peer_Address_Type, BD_ADDR_TYPE Peer_Address,
		ADV_CH_MAP Advertising_Channel_Map, uint8_t Advertising_Filter_Policy )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 15;
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_ADVERTISING_PARAMETERS;
	PcktPtr->CmdPacket.Parameter_Total_Length = 15;

	PcktPtr->CmdPacket.Parameter[0] = Advertising_Interval_Min & 0xFF;
	PcktPtr->CmdPacket.Parameter[1] = ( Advertising_Interval_Min >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[2] = Advertising_Interval_Max & 0xFF;
	PcktPtr->CmdPacket.Parameter[3] = ( Advertising_Interval_Max >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[4] = Advertising_Type;

	PcktPtr->CmdPacket.Parameter[5] = Own_Address_Type;

	PcktPtr->CmdPacket.Parameter[6] = Peer_Address_Type;

	for( int8_t i = 0; i < sizeof(Peer_Address); i++ )
	{
		PcktPtr->CmdPacket.Parameter[i + 7] = Peer_Address.Byte[i];
	}

	PcktPtr->CmdPacket.Parameter[13] = Advertising_Channel_Map.Val;

	PcktPtr->CmdPacket.Parameter[14] = Advertising_Filter_Policy;

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Parameters_Status()       			*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Advertising_Parameters command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Parameters_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Parameters_Complete()       			*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Advertising_Parameters command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Parameters_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_Advertising_Physical_Channel_Tx_Power()          */
/* Location: Page 2486 Core_v5.2								*/
/* Purpose: The 												*/
/* HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command is */
/* used by the Host to read the transmit power level used for 	*/
/* LE advertising physical channel packets.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Read_Advertising_Physical_Channel_Tx_Power( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_LE_READ_ADV_PHY_CHANNEL_TX_POWER;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Read_Advertising_Physical_Channel_Tx_Power_Status() 	*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command.	*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_Advertising_Physical_Channel_Tx_Power_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_Advertising_Physical_Channel_Tx_Power_Complete()	*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command.	*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_Advertising_Physical_Channel_Tx_Power_Complete( CONTROLLER_ERROR_CODES Status, int8_t TX_Power_Level )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Data()                                */
/* Location: Page 2487 Core_v5.2								*/
/* Purpose: The HCI_LE_Set_Advertising_Data command is used to  */
/* set the data used in advertising packets that have a data 	*/
/* field. Only the significant part of the Advertising_Data 	*/
/* should be transmitted in the advertising packets, as defined */
/* in [Vol 3] Part C, Section 11. If advertising is currently 	*/
/* enabled, the Controller shall use the new data in subsequent */
/* advertising events. If an advertising event is in progress 	*/
/* when this command is issued, the Controller may use the old 	*/
/* or new data for that event. If advertising is currently 		*/
/* disabled, the data shall be kept by the Controller and used 	*/
/* once advertising is enabled.									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Advertising_Data( uint8_t Advertising_Data_Length, uint8_t Advertising_Data[] )
{
	uint8_t Status = FALSE;

	if( Advertising_Data_Length <= MAX_ADVERTISING_DATA_LENGTH )
	{

		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + Advertising_Data_Length;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_ADVERTISING_DATA;
		PcktPtr->CmdPacket.Parameter_Total_Length = Advertising_Data_Length;

		for( uint8_t i = 0; i < Advertising_Data_Length; i++ )
		{
			PcktPtr->CmdPacket.Parameter[i] = Advertising_Data[i];
		}

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );
	}

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Data_Status()                         */
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_LE_Set_Advertising_Data	*/
/* command.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Data_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Data_Complete()                       */
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_LE_Set_Advertising_Data	*/
/* command.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Data_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Scan_Response_Data()                              */
/* Location: Page 2489 Core_v5.2								*/
/* Purpose: This command is used to provide data used in 		*/
/* Scanning Packets that have a data field. Only the significant*/
/* part of the Scan_Response_Data should be transmitted in the	*/
/* Scanning Packets, as defined in [Vol 3] Part C, Section 11.	*/
/* If advertising is currently enabled, the Controller shall use*/
/* the new data in subsequent advertising events. If an 		*/
/* advertising event is in progress when this command is issued,*/
/* the Controller may use the old or new data for that event. If*/
/* advertising is currently disabled, the data shall be kept by */
/* the Controller and used once advertising is enabled.			*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Scan_Response_Data( uint8_t Scan_Response_Data_Length, uint8_t* Scan_Response_Data )
{
	uint8_t Status = FALSE;

	if( Scan_Response_Data_Length <= MAX_SCAN_RESPONSE_DATA_LENGTH )
	{

		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + Scan_Response_Data_Length;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_SCAN_RESPONSE_DATA;
		PcktPtr->CmdPacket.Parameter_Total_Length = Scan_Response_Data_Length;

		for( uint8_t i = 0; i < Scan_Response_Data_Length; i++ )
		{
			PcktPtr->CmdPacket.Parameter[i] = Scan_Response_Data[i];
		}

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );
	}

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Scan_Response_Data_Status()                       */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Scan_Response_Data command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Scan_Response_Data_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Scan_Response_Data_Complete()                     */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Scan_Response_Data command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Scan_Response_Data_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Enable()                              */
/* Location: Page 2491 Core_v5.2								*/
/* Purpose: The HCI_LE_Set_Advertising_Enable command is used to*/
/* request the Controller to start or stop advertising. The 	*/
/* Controller manages the timing of advertisements as per the 	*/
/* advertising parameters given in the 							*/
/* HCI_LE_Set_Advertising_Parameters command. The Controller 	*/
/* shall continue advertising until the Host issues an			*/
/* HCI_LE_Set_Advertising_Enable command with Advertising_Enable*/
/* set to 0x00 (Advertising is disabled) or until a connection 	*/
/* is created or until the Advertising is timed out due to high */
/* duty cycle Directed Advertising. In these cases, advertising */
/* is then disabled. If Advertising_Enable is set to 0x01, the  */
/* advertising parameters' Own_Address_Type parameter is set to */
/* 0x01, and the random address for the device has not been 	*/
/* initialized, the Controller shall return the error code 		*/
/* Invalid HCI Command Parameters (0x12). If Advertising_Enable */
/* is set to 0x01, the advertising parameters' Own_Address_Type */
/* parameter is set to 0x03, the controller's resolving list did*/
/* not contain a matching entry, and the random address for the */
/* device has not been initialized, the Controller shall return */
/* the error code Invalid HCI Command Parameters (0x12). 		*/
/* Enabling advertising when it is already enabled can cause the*/
/* random address to change. Disabling advertising when it is 	*/
/* already disabled has no effect.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Advertising_Enable( uint8_t Advertising_Enable )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + sizeof(Advertising_Enable);
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_ADVERTISING_ENABLE;
	PcktPtr->CmdPacket.Parameter_Total_Length = sizeof(Advertising_Enable);

	PcktPtr->CmdPacket.Parameter[0] = Advertising_Enable;

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Enable_Status()                 	    */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Advertising_Enable command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Enable_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Enable_Complete()                 	*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Advertising_Enable command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Enable_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Scan_Parameters()                    		        */
/* Location: Page 2493 Core_v5.2								*/
/* Purpose: The HCI_LE_Set_Scan_Parameters command is used to 	*/
/* set the scan parameters. The LE_Scan_Type parameter controls */
/* the type of scan to perform. The LE_Scan_Interval and 		*/
/* LE_Scan_Window parameters are recommendations from the Host 	*/
/* on how long (LE_Scan_Window) and how frequently 				*/
/* (LE_Scan_Interval) the Controller should scan (See [Vol 6] 	*/
/* Part B, Section 4.4.3). The LE_Scan_Window parameter shall 	*/
/* always be set to a value smaller or equal to the value set	*/
/* for the LE_Scan_Interval parameter. If they are set to the 	*/
/* same value scanning should be run continuously. 				*/
/* Own_Address_Type parameter indicates the type of address 	*/
/* being used in the scan request packets. The Host shall not 	*/
/* issue this command when scanning is enabled in the 			*/
/* Controller if it is the Command Disallowed error code shall 	*/
/* be used.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Scan_Parameters( LE_SCAN_TYPE LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window,
		ADDRESS_TYPE Own_Address_Type, uint8_t Scanning_Filter_Policy )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 7;
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_SCAN_PARAMETERS;
	PcktPtr->CmdPacket.Parameter_Total_Length = 7;

	PcktPtr->CmdPacket.Parameter[0] = LE_Scan_Type;

	PcktPtr->CmdPacket.Parameter[1] = LE_Scan_Interval & 0xFF;
	PcktPtr->CmdPacket.Parameter[2] = ( LE_Scan_Interval >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[3] = LE_Scan_Window & 0xFF;
	PcktPtr->CmdPacket.Parameter[4] = ( LE_Scan_Window >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[5] = Own_Address_Type;

	PcktPtr->CmdPacket.Parameter[6] = Scanning_Filter_Policy;

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Scan_Parameters_Status()                 			*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Scan_Parameters command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Scan_Parameters_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Scan_Parameters_Complete()                 		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Scan_Parameters command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Scan_Parameters_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Scan_Enable()                	    		        */
/* Location: Page 2496 Core_v5.2								*/
/* Purpose: The HCI_LE_Set_Scan_Enable command is used to start */
/* and stop scanning. Scanning is used to discover advertising  */
/* devices nearby. The Filter_Duplicates parameter controls 	*/
/* whether the Link Layer should filter out duplicate 			*/
/* advertising reports (Filtering_Enabled) to the Host, or if 	*/
/* the Link Layer should generate advertising reports for each 	*/
/* packet received (Filtering_Disabled). See [Vol 6] Part B, 	*/
/* Section 4.4.3.5. If LE_Scan_Enable is set to 0x00 then 		*/
/* Filter_Duplicates shall be ignored. If LE_Scan_Enable is set */
/* to 0x01, the scanning parameters' Own_Address_Type parameter */
/* is set to 0x01 or 0x03, and the random address for the device*/
/* has not been initialized, the Controller shall return the 	*/
/* error code Invalid HCI Command Parameters (0x12). If the 	*/
/* LE_Scan_Enable parameter is set to 0x01 and scanning is 		*/
/* already enabled, any change to the Filter_Duplicates setting */
/* shall take effect. Disabling scanning when it is disabled has*/
/* no effect.													*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Scan_Enable( uint8_t LE_Scan_Enable, uint8_t Filter_Duplicates )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 2;
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_SCAN_ENABLE;
	PcktPtr->CmdPacket.Parameter_Total_Length = 2;

	PcktPtr->CmdPacket.Parameter[0] = LE_Scan_Enable;
	PcktPtr->CmdPacket.Parameter[1] = Filter_Duplicates;

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Scan_Enable_Status()           		      		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Scan_Enable command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Scan_Enable_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Scan_Enable_Complete()           		      		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Set_Scan_Enable command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Scan_Enable_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Create_Connection()                	    		    */
/* Location: Page 2498 Core_v5.2								*/
/* Purpose: The HCI_LE_Create_Connection command is used to 	*/
/* create an ACL connection to a connectable advertiser. The 	*/
/* LE_Scan_Interval and LE_Scan_Window parameters are recommen-	*/
/* dations from the Host on how long (LE_Scan_Window) and how	*/
/* frequently (LE_Scan_Interval) the Controller should scan. The*/
/* LE_Scan_Window parameter shall be set to a value smaller or  */
/* equal to the value set for the LE_Scan_Interval parameter. 	*/
/* If both are set to the same value, scanning should run 		*/
/* continuously. The Initiator_Filter_Policy is used to 		*/
/* determine whether the White List is used. If the White List  */
/* is not used, the Peer_Address_Type and the Peer_Address 		*/
/* parameters specify the address type and address of the 		*/
/* advertising device to connect to. Peer_Address_Type parameter*/
/* indicates the type of address used in the connectable 		*/
/* advertisement sent by the peer. The Host shall not set		*/
/* Peer_Address_Type to either 0x02 or 0x03 if both the Host 	*/
/* and the Controller support the HCI_LE_Set_Privacy_Mode 		*/
/* command. If a Controller that supports the 					*/
/* HCI_LE_Set_Privacy_Mode command receives the					*/
/* HCI_LE_Create_Connection command with Peer_Address_Type set 	*/
/* to either 0x02 or 0x03, it may use either device privacy 	*/
/* mode or network privacy mode for that peer device. 			*/
/* Peer_Address parameter indicates the Peer’s Public 			*/
/* Device Address, Random (static) Device Address, 				*/
/* Non-Resolvable Private Address or Resolvable	Private Address */
/* depending on the Peer_Address_Type parameter. 				*/
/* Own_Address_Type parameter indicates the type of address 	*/
/* being used in the connection request packets. The 			*/
/* Connection_Interval_Min and Connection_Interval_Max 			*/
/* parameters define the minimum and maximum allowed connection */
/* interval. The Connection_Interval_Min parameter shall not be */
/* greater than the Connection_Interval_Max parameter. The 		*/
/* Connection_Latency parameter defines the maximum allowed 	*/
/* connection latency (see [Vol 6] Part B, Section 4.5.1).		*/
/* The Supervision_Timeout parameter defines the link 			*/
/* supervision timeout for the connection. The 					*/
/* Supervision_Timeout in milliseconds shall be larger than		*/
/* (1 + Connection_Latency) * Connection_Interval_Max * 2, where*/
/* Connection_Interval_Max is given in milliseconds. (See		*/
/* [Vol 6] Part B, Section 4.5.2). The Min_CE_Length and 		*/
/* Max_CE_Length parameters are informative	parameters providing*/
/* the Controller with the expected minimum and maximum length 	*/
/* of the connection events. The Min_CE_Length parameter shall 	*/
/* be less than or equal to the Max_CE_Length parameter. If the */
/* Host issues this command when another 						*/
/* HCI_LE_Create_Connection command is pending in the 			*/
/* Controller, the Controller shall return the error code		*/
/* Command Disallowed (0x0C). If the Own_Address_Type parameter */
/* is set to 0x01 and the random address for the device has not */
/* been initialized, the Controller shall return the error code */
/* Invalid HCI Command Parameters (0x12). If the 				*/
/* Own_Address_Type parameter is set to 0x03, the 				*/
/* Initiator_Filter_Policy parameter is set to 0x00, the 		*/
/* controller's resolving list did not contain a matching entry,*/
/* and the random address for the device has not been 			*/
/* initialized, the Controller shall return the error code		*/
/* Invalid HCI Command Parameters (0x12). If the				*/
/* Own_Address_Type parameter is set to 0x03, the 				*/
/* Initiator_Filter_Policy parameter is set to 0x01, and the 	*/
/* random address for the device has not been initialized, the 	*/
/* Controller shall return the error code Invalid HCI Command	*/
/* Parameters (0x12).											*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Create_Connection( uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Initiator_Filter_Policy,
		ADDRESS_TYPE Peer_Address_Type, BD_ADDR_TYPE Peer_Address, ADDRESS_TYPE Own_Address_Type,
		uint16_t Connection_Interval_Min, uint16_t Connection_Interval_Max, uint16_t Connection_Latency,
		uint16_t Supervision_Timeout, uint16_t Min_CE_Length, uint16_t Max_CE_Length )
{
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 25;
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_CREATE_CONNECTION;
	PcktPtr->CmdPacket.Parameter_Total_Length = 25;

	PcktPtr->CmdPacket.Parameter[0] = LE_Scan_Interval & 0xFF;
	PcktPtr->CmdPacket.Parameter[1] = ( LE_Scan_Interval >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[2] = LE_Scan_Window & 0xFF;
	PcktPtr->CmdPacket.Parameter[3] = ( LE_Scan_Window >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[4] = Initiator_Filter_Policy;

	PcktPtr->CmdPacket.Parameter[5] = Peer_Address_Type;

	for( int8_t i = 0; i < sizeof(Peer_Address); i++ )
	{
		PcktPtr->CmdPacket.Parameter[i + 6] = Peer_Address.Byte[i];
	}

	PcktPtr->CmdPacket.Parameter[12] = Own_Address_Type;

	PcktPtr->CmdPacket.Parameter[13] = Connection_Interval_Min & 0xFF;
	PcktPtr->CmdPacket.Parameter[14] = ( Connection_Interval_Min >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[15] = Connection_Interval_Max & 0xFF;
	PcktPtr->CmdPacket.Parameter[16] = ( Connection_Interval_Max >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[17] = Connection_Latency & 0xFF;
	PcktPtr->CmdPacket.Parameter[18] = ( Connection_Latency >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[19] = Supervision_Timeout & 0xFF;
	PcktPtr->CmdPacket.Parameter[20] = ( Supervision_Timeout >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[21] = Min_CE_Length & 0xFF;
	PcktPtr->CmdPacket.Parameter[22] = ( Min_CE_Length >> 8 ) & 0xFF;

	PcktPtr->CmdPacket.Parameter[23] = Max_CE_Length & 0xFF;
	PcktPtr->CmdPacket.Parameter[24] = ( Max_CE_Length >> 8 ) & 0xFF;

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Create_Connection_Status()           		      		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Create_Connection command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Create_Connection_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Create_Connection_Cancel()                            */
/* Location: Page 2503 Core_v5.2								*/
/* Purpose: The HCI_LE_Create_Connection_Cancel command is used */
/* to cancel the HCI_LE_Create_Connection or 					*/
/* HCI_LE_Extended_Create_Connection commands. This command 	*/
/* shall only be issued after the HCI_LE_Create_Connection or   */
/* HCI_LE_Extended_Create_Connection commands have been issued, */
/* an HCI_Command_Status event has been received for the 		*/
/* HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection*/
/* commands, and before the HCI_LE_Connection_Complete or 		*/
/* HCI_LE_Enhanced_Connection_Complete events.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Create_Connection_Cancel( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_LE_CREATE_CONNECTION_CANCEL;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Create_Connection_Cancel_Status()               		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Create_Connection_Cancel command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Create_Connection_Cancel_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Create_Connection_Cancel_Complete()               	*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Create_Connection_Cancel command.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Create_Connection_Cancel_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_White_List_Size()                            	*/
/* Location: Page 2505 Core_v5.2								*/
/* Purpose: The HCI_LE_Read_White_List_Size command is used to 	*/
/* read the total number of White List entries that can be 		*/
/* stored in the Controller. Note: The number of entries that 	*/
/* can be stored is not fixed and the Controller can change it  */
/* at any time (e.g. because the memory used to store the White */
/* List can also be used for other purposes).					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Read_White_List_Size( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_LE_READ_WHITE_LIST_SIZE;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Read_White_List_Size_Status()               			*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_White_List_Size command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_White_List_Size_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Read_White_List_Size_Complete()               		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Read_White_List_Size command.							*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Read_White_List_Size_Complete( CONTROLLER_ERROR_CODES Status, uint8_t White_List_Size )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Clear_White_List()                            		*/
/* Location: Page 2506 Core_v5.2								*/
/* Purpose: The HCI_LE_Clear_White_List command is used to clear*/
/* the White List stored in the Controller. This command shall  */
/* not be used when:											*/
/* • any advertising filter policy uses the White List and 		*/
/* advertising is enabled,										*/
/* • the scanning filter policy uses the White List and scanning*/
/* is enabled, or												*/
/* • the initiator filter policy uses the White List and an	    */
/* HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection*/
/* command is outstanding.										*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Clear_White_List( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_LE_CLEAR_WHITE_LIST;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Clear_White_List_Status()             		  		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Clear_White_List command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Clear_White_List_Status( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Clear_White_List_Complete()             		  		*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_LE_Clear_White_List command.								*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Clear_White_List_Complete( CONTROLLER_ERROR_CODES Status )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Hardware_Error()                							*/
/* Location: 					 								*/
/* Purpose: Event used to notify the Host that a hardware		*/
/* failure has occurred in the Controller.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Hardware_Error( BLE_HW_ERROR_CODE Hardware_Code )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* End of file	                                                */
/****************************************************************/
