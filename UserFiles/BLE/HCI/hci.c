

/****************************************************************/
/* Includes                                                     */
/****************************************************************/
#include "hci.h"
#include "hci_transport_layer.h"
#include "Types.h"


/****************************************************************/
/* Type Defines                                                 */
/****************************************************************/


/****************************************************************/
/* Static functions declaration                                 */
/****************************************************************/


/****************************************************************/
/* Defines                                                      */
/****************************************************************/


/****************************************************************/
/* Global variables definition                                  */
/****************************************************************/


/****************************************************************/
/* Local variables definition                                   */
/****************************************************************/


/****************************************************************/
/* HCI_Disconnect()                         					*/
/* Location: Page 1940 Core_v5.2 								*/
/* Purpose: The HCI_Disconnect command is used to terminate an 	*/
/* existing connection. The Connection_Handle command parameter */
/* indicates which connection is to be disconnected. The Reason */
/* command parameter indicates the reason for ending the 		*/
/* connection and is copied into the error code field of the	*/
/* LMP_DETACH PDU on a BR/EDR connection or the error code field*/
/* of the LL_TERMINATE_IND PDU, or the LL_CIS_TERMINATE_IND PDU */
/* on an LE connection. All SCO, eSCO, and CIS connections on a */
/* physical link should be disconnected before the ACL 			*/
/* connection on the same physical connection is disconnected. 	*/
/* If it does not, they will be implicitly disconnected as part */
/* of the ACL disconnection. If this command is used to 		*/
/* disconnect a CIS, the connection handle of the CIS and the	*/
/* associated data paths of the CIS shall remain valid. If this */
/* command is issued for a CIS before the Controller has		*/
/* generated the HCI_CIS_Established event for that CIS, the 	*/
/* Controller shall return the error code Command Disallowed 	*/
/* (0x0C). Note: The Host can recreate a disconnected CIS at a 	*/
/* later point in time using the same connection handle.		*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Disconnect( uint16_t Connection_Handle, CONTROLLER_ERROR_CODES Reason )
{
	uint8_t Status = FALSE;

	if( Connection_Handle <= MAX_CONNECTION_HANDLE )
	{

		switch( Reason )
		{
		/* Not sure if other reason codes are supported. In the command specification, it
		 * explicit mentioned those: */
		case AUTHENTICATION_FAILURE:
		case REMOTE_USER_TERMINATED_CONNECTION:
		case REM_DEV_TERM_CONN_LOW_RESOURCES:
		case REM_DEV_TERM_CONN_POWER_OFF:
		case UNSUPPORTED_REMOTE_OR_LMP_FEATURE:
		case PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED:
		case UNACCEPTABLE_CONNECTION_PARAMETERS:
			break;

		default:
			return (Status);
			break;
		}

		uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + 3;
		HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

		PcktPtr->PacketType = HCI_COMMAND_PACKET;
		PcktPtr->CmdPacket.OpCode.Val = HCI_DISCONNECT;
		PcktPtr->CmdPacket.Parameter_Total_Length = 3;

		PcktPtr->CmdPacket.Parameter[0] = Connection_Handle & 0xFF;
		PcktPtr->CmdPacket.Parameter[1] = ( Connection_Handle >> 8 ) & 0xFF;
		PcktPtr->CmdPacket.Parameter[2] = Reason;

		Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

		free( PcktPtr );

	}

	return (Status);
}


/****************************************************************/
/* HCI_Disconnect_Status()        	        					*/
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Disconnect command and HCI_Disconnection_Complete not	*/
/* issued yet.													*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Disconnect_Status( CONTROLLER_ERROR_CODES Reason )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Version_Information()                         */
/* Location: Page 2223 Core_v5.2 								*/
/* Purpose: The HCI_Read_Local_Version_Information command 		*/
/* reads the values for the version information for the local	*/
/* Controller.   		    									*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_Read_Local_Version_Information( void )
{
	uint8_t Status;

	HCI_SERIAL_COMMAND_PCKT Pckt;

	Pckt.PacketType = HCI_COMMAND_PACKET;
	Pckt.CmdPacket.OpCode.Val = HCI_READ_LOCAL_VERSION_INFORMATION;
	Pckt.CmdPacket.Parameter_Total_Length = 0;

	Status = HCI_Transmit( &Pckt, sizeof(Pckt), CALL_BACK_AFTER_TRANSFER, NULL );

	return (Status);
}


/****************************************************************/
/* HCI_Read_Local_Version_Information_Status()          	    */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Local_Version_Information command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Version_Information_Status( CONTROLLER_ERROR_CODES Reason )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Read_Local_Version_Information_Complete()                */
/* Location: 					 								*/
/* Purpose: Event generated by the 								*/
/* HCI_Read_Local_Version_Information command.					*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Read_Local_Version_Information_Complete( CONTROLLER_ERROR_CODES ErrorCode,
		HCI_VERSION HCI_Version, uint16_t HCI_Revision,
		uint8_t LMP_PAL_Version, uint16_t Manufacturer_Name,
		uint16_t LMP_PAL_Subversion)
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Data()                                */
/* Location: 					 								*/
/* Purpose: The HCI_LE_Set_Advertising_Data command is used to  */
/* set the data used in advertising packets that have a data 	*/
/* field.    		    										*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
uint8_t HCI_LE_Set_Advertising_Data( uint8_t Advertising_Data_Length, uint8_t Advertising_Data[] )
{
	/* TODO: finalizar */
	/* todo: VERIFICAR SE O CONTROLLER PODE ACEITAR ESTE COMANDO */
	/* TODO? verificar se devemos limitar a uma única chamada por vez, visto que podem ser empilhados
	 * vários comandos. O usuário pode monitor a nível de aplicação com um cpodigo para cada empilhamento
	 * acho que não compete a este driver fazer isto.
	 */
	uint8_t Status;

	uint16_t ByteArraySize = sizeof(HCI_SERIAL_COMMAND_PCKT) + Advertising_Data_Length;
	HCI_SERIAL_COMMAND_PCKT* PcktPtr = malloc( ByteArraySize );

	PcktPtr->PacketType = HCI_COMMAND_PACKET;
	PcktPtr->CmdPacket.OpCode.Val = HCI_LE_SET_ADVERTISING_DATA;
	PcktPtr->CmdPacket.Parameter_Total_Length = Advertising_Data_Length;

	for( uint8_t i = 0; i < Advertising_Data_Length; i++ )
	{
		PcktPtr->CmdPacket.Parameter[i] = Advertising_Data[i];
	}

	Status = HCI_Transmit( PcktPtr, ByteArraySize, CALL_BACK_AFTER_TRANSFER, NULL );

	free( PcktPtr );

	return (Status);
}


/****************************************************************/
/* HCI_LE_Set_Advertising_Data_Response()                       */
/* Location: 					 								*/
/* Purpose: Event generated by the HCI_LE_Set_Advertising_Data	*/
/* command.														*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_LE_Set_Advertising_Data_Response( EVENT_CODE Event, CONTROLLER_ERROR_CODES ErrorCode )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* HCI_Hardware_Error()                							*/
/* Location: 					 								*/
/* Purpose: Event used to notify the Host that a hardware		*/
/* failure has occurred in the Controller.						*/
/* Parameters: none				         						*/
/* Return: none  												*/
/* Description:													*/
/****************************************************************/
__attribute__((weak)) void HCI_Hardware_Error( BLE_HW_ERROR_CODE Hardware_Code )
{
	/* The user should implement at higher layers since it is weak. */
}


/****************************************************************/
/* End of file	                                                */
/****************************************************************/
